
module Clips
  module Api
    class DataObject < FFI::Struct
      class << self
        def intern(attrs={})
          obj = new
          attrs.each_pair {|key, value| obj[key] = value }
          obj
        end
        
        def type_str(type)
          constant = constants.find {|const| const_get(const) == type }
          constant ? constant.to_s : nil
        end
      end
      
      # see constant.h
      FLOAT            = 0
      INTEGER          = 1
      SYMBOL           = 2
      STRING           = 3
      MULTIFIELD       = 4
      EXTERNAL_ADDRESS = 5
      FACT_ADDRESS     = 6
      INSTANCE_ADDRESS = 7
      INSTANCE_NAME    = 8
      
      CAST = {
        FLOAT => Struct::FloatHashNode,
        INTEGER => Struct::IntegerHashNode,
        SYMBOL => Struct::SymbolHashNode,
        STRING => Struct::SymbolHashNode,
        EXTERNAL_ADDRESS => Struct::ExternalAddressHashNode
      }
      
      @@@
      struct do |s|
        s.name 'struct dataObject'
        s.include 'clips.h'
        
        s.field :supplementalInfo, :pointer
        s.field :type,  :ushort
        s.field :value, :pointer
        s.field :begin, :long
        s.field :end,   :long
        s.field :next,  :pointer
      end
      @@@
      
      def type
        DataObject.type_str(self[:type])
      end
      
      # Duplicates SYMBOL and STRING values when dup is true, as prescribed in
      # the apg:
      #
      #   Do not store the pointer returned by DOToString or DOPToString as part
      #   of a permanent data structure. When CLIPS performs garbage collection
      #   on symbols and strings, the pointer reference to the string may be
      #   rendered invalid. To store a permanent reference to a string, allocate
      #   storage for a copy of the string and then copy the string returned by
      #   DOToString or DOPToString to the copyâ€™s storage area.
      #
      def value(dup=true)
        struct = CAST[self[:type]]
        raise "cannot cast type: #{self[:type]} (#{type})" unless struct
        value = struct.new(self[:value])[:contents]
        
        if struct != Struct::SymbolHashNode
          return value 
        end
        
        case value
        when "TRUE"  then true
        when "FALSE" then false
        else dup ? value.dup : value
        end
      end
    end
  end
end